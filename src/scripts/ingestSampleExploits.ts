import fs from 'fs';
import { PrismaClient } from '@prisma/client';

// Initialize Prisma client
const prisma = new PrismaClient();

// Convert USD string to lamports (1 SOL = 1e9 lamports, assume $140/SOL)
function usdToLamports(usdStr: string): bigint {
  const usd = parseFloat(usdStr.replace('$', '').replace(/,/g, ''));
  const solPrice = 140; // $140 per SOL
  const sol = usd / solPrice;
  return BigInt(Math.round(sol * 1e9));
}

async function ingestSampleExploits(filePath: string) {
  try {
    // Read and parse JSON
    const raw = fs.readFileSync(filePath, 'utf-8');
    const exploitData = JSON.parse(raw);

    let count = 0;

    for (const exploit of exploitData) {
      const date = new Date(exploit.date);
      if (isNaN(date.getTime())) {
        console.warn(`Invalid date for ${exploit.protocol}: ${exploit.date}, skipping`);
        continue;
      }

      const fundsLost = usdToLamports(exploit.fundsLost);
      const txIds = Array.isArray(exploit.txIds) ? exploit.txIds : [];

      const metadata = exploit.metadata || {};

      await prisma.exploit.upsert({
        where: { id: metadata.id || `${exploit.protocol}-${date.toISOString()}` },
        update: {},
        create: {
          id: metadata.id || `${exploit.protocol}-${date.toISOString()}`, // Fallback if no ID
          date,
          protocol: exploit.protocol || 'Unknown',
          type: exploit.type || 'Unknown',
          fundsLost,
          txIds,
          description: exploit.description || `Exploit on ${exploit.protocol}`,
          codeSnippet: exploit.codeSnippet || null,
          status: exploit.status || 'Unknown',
          metadata,
        },
      });

      count++;
    }

    console.log(`✅ Successfully ingested ${count} exploits.`);
  } catch (error) {
    console.error('❌ Error ingesting sample exploit data:', (error as any).message);
  } finally {
    await prisma.$disconnect();
  }
}

// Run it
ingestSampleExploits('exploits.json').catch(console.error);
