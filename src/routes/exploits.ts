import { Router } from 'express';
import { prisma } from '../index'

// Helper function to convert BigInt to string in objects
const serializeBigInt = (obj: any): any => {
  return JSON.parse(
    JSON.stringify(obj, (key, value) =>
      typeof value === 'bigint' ? value.toString() : value
    )
  );
};

const router = Router();

// GET /exploits - Fetch list of exploits with optional filters
router.get('/', async (req, res) => {
  try {
    const { date, protocol, type } = req.query;
    const filters: any = {};

    if (date) filters.date = { equals: new Date(date as string) };
    if (protocol) filters.protocol = { equals: protocol as string };
    if (type) filters.type = { equals: type as string };

    const exploits = await prisma.exploit.findMany({
      where: filters,
      orderBy: { date: 'desc' },
    });

    // Serialize BigInt fields
    const serializedExploits = serializeBigInt(exploits);
    res.json(serializedExploits);
  } catch (error) {
    console.error('Error fetching exploits:', error);
    res.status(500).json({ error: 'Failed to fetch exploits' });
  }
});

// GET /exploits/:id - Fetch a single exploit by ID
//@ts-ignore
router.get('/:id', async (req, res) => {
  try {
    const exploit = await prisma.exploit.findUnique({
      where: { id: req.params.id },
    });

    if (!exploit) {
      return res.status(404).json({ error: 'Exploit not found' });
    }

    // Serialize BigInt fields
    const serializedExploit = serializeBigInt(exploit);
    res.json(serializedExploit);
  } catch (error) {
    console.error('Error fetching exploit:', error);
    res.status(500).json({ error: 'Failed to fetch exploit' });
  }
});

// POST /exploits - Create a new exploit (admin use)
//@ts-ignore
router.post('/', async (req, res) => {
  try {
    const { date, protocol, type, fundsLost, txIds, description, codeSnippet, status } = req.body;

    // Basic validation
    if (!date || !protocol || !type || !fundsLost || !txIds || !description || !status) {
      return res.status(400).json({ error: 'Missing required fields' });
    }

    const exploit = await prisma.exploit.create({
      data: {
        date: new Date(date),
        protocol,
        type,
        fundsLost: BigInt(fundsLost), // Ensure fundsLost is BigInt
        txIds,
        description,
        codeSnippet,
        status,
      },
    });

    // Serialize BigInt fields
    const serializedExploit = serializeBigInt(exploit);
    res.status(201).json(serializedExploit);
  } catch (error) {
    console.error('Error creating exploit:', error);
    res.status(500).json({ error: 'Failed to create exploit' });
  }
});

export default router;